package script

import (
	"bytes"
	"fmt"
	"github.com/iancoleman/strcase"
	"github.com/kr/pretty"
	"go/doc"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"regexp"
	"strings"
	"text/template"
)

const importPath = "github.com/justjake/go-scripting/script"

const templateRaw = `package {{ .Package }}

// THIS FILE WAS AUTO-GENERATED BY go-scripting-ui.
// RUN 'go generate' TO UPDATE IT.

import "{{ .ImportPath }}"

type generatedUI struct {
	// It's up to you to set 'UI.Implementation = &yourImpl{}' in your main().
	Impl {{ .Recv }}
	script.UI
}

func (ui *generatedUI) getCommandMethod(commandName string) (func(), bool) {
	switch commandName {
{{- range .UI.Commands }}
	case {{ printf "%q" .Name }}:
		return ui.Impl.{{ .Original }}, true
{{- end }}
	default:
		return nil, false
	}
}

// UI is an auto-generated UI that describes this program's commands and arguments.
// To use:
//
//   func main() {
//   	UI.Impl = &yourStruct{...} // assign a {{ .Recv }}
//   	UI.Run(UI.getCommandMethod, os.Args[1:]) // All given command names will be run
//   }
var UI = &generatedUI{
	UI: {{ .Serialized }},
}
`

var tmpl = template.Must(template.New("file").Parse(templateRaw))

// NameStyle defines how UI will transform names from those in the file to
// those used in the UI.
type NameStyle string

const (
	// NoChange means names will not be transformed
	NoChange = ""
	// KebabCase means NamesOfAny_Format will end up like names-of-any-format
	KebabCase = "kebab-case"
	// ScreamingSnakeCase means NamesOfAny_Format will end up like NAMES_OF_ANY_FORMAT
	ScreamingSnakeCase = "SNAKE_CASE"
)

type uiparser struct {
	fset *token.FileSet
	pkg  *doc.Package
	*UI
	CommandStyle NameStyle
	ArgStyle     NameStyle
	IsArg        func(*doc.Func) bool
	IsCommand    func(*doc.Func) bool
	// Type name of the reciever that we should discover commands from.
	Recv string
}

// IsPublic returns true if the function is public.
func IsPublic(fn *doc.Func) bool {
	return string(fn.Name[0]) == strings.ToUpper(string(fn.Name[0]))
}

// IsScreamingSnake returns true if the function is named in SCREAMING_SNAKE_CASE
func IsScreamingSnake(fn *doc.Func) bool {
	return fn.Name == strcase.ToScreamingSnake(fn.Name)
}

func transformName(name string, style NameStyle) string {
	if style == KebabCase {
		return strcase.ToKebab(name)
	}

	if style == ScreamingSnakeCase {
		return strcase.ToScreamingSnake(name)
	}

	return name
}

func loadPackageAt(path string) (*token.FileSet, *doc.Package, error) {
	fset := token.NewFileSet()
	packages, err := parser.ParseDir(fset, path, nil, parser.ParseComments)
	if err != nil {
		return nil, nil, err
	}
	if len(packages) != 1 {
		return nil, nil, fmt.Errorf("wrong number of packages; should be one: %v", packages)
	}
	for _, pkg := range packages {
		return fset, doc.New(pkg, path, 0), nil
	}
	return nil, nil, fmt.Errorf("unreachable")
}

// Parse parses a package's documentation into a UI structure.
func Parse(fset *token.FileSet, pkg *doc.Package, recv string) (*UI, error) {
	p := &uiparser{
		fset:         fset,
		pkg:          pkg,
		UI:           &UI{},
		CommandStyle: KebabCase,
		ArgStyle:     "",
		IsCommand:    IsPublic,
		IsArg:        IsScreamingSnake,
		Recv:         recv,
	}
	var err error

	p.UI.Args, err = p.FindArgs()
	if err != nil {
		return nil, err
	}

	p.UI.Commands, err = p.FindCommands()
	if err != nil {
		return nil, err
	}

	return p.UI, nil
}

// Serialize a UI as Golang source code
func Serialize(ui *UI) string {
	var tmp bytes.Buffer
	pretty.Fprintf(&tmp, "%# v", ui)
	bytes := tmp.Bytes()

	// the pretty printer we use should output slice type names, but does not.
	// so we manually re-add slice type names.
	bytes = regexp.MustCompile(`(?m)^(\s+)Commands:\s+\{`).ReplaceAll(
		bytes, []byte("${1}Commands: []script.Command{"))
	bytes = regexp.MustCompile(`(?m)^(\s+)Args:\s+\{`).ReplaceAll(
		bytes, []byte("${1}Commands: []script.Arg{"))
	bytes = regexp.MustCompile(`(?m)^(\s+)(Optional|Required|Tags):\s+\{`).ReplaceAll(
		bytes, []byte("${1}${2}: []string{"))

	// format with the go source code formatter
	fmted, err := format.Source(bytes)
	if err != nil {
		panic(err)
	}

	return string(fmted)
}

func ToFileContents(ui *UI, recv string) string {
	var out bytes.Buffer
	params := struct {
		Package    string
		ImportPath string
		UI         *UI
		Serialized string
		Recv       string
	}{
		Package:    "main",
		ImportPath: importPath,
		UI:         ui,
		Serialized: Serialize(ui),
		Recv:       recv,
	}
	err := tmpl.Execute(&out, params)
	if err != nil {
		panic(err)
	}
	formatted, err := format.Source(out.Bytes())
	if err != nil {
		panic(err)
	}
	return string(formatted)
}

func (p *uiparser) FindArgs() ([]Arg, error) {
	res := []Arg{}

	for _, fn := range p.Funcs() {
		if !p.IsArg(fn) {
			continue
		}

		desc, err := p.ParseDescription(fn)
		if err != nil {
			return nil, fmt.Errorf("%s: cannot parse script.Arg: %v", p.fmtfunc(fn), err)
		}
		desc.Name = transformName(desc.Name, p.ArgStyle)

		res = append(res, Arg{*desc})
	}
	return res, nil
}

func (p *uiparser) FindCommands() ([]Command, error) {
	res := []Command{}
	for _, fn := range p.Funcs() {
		if !p.IsCommand(fn) {
			continue
		}
		if p.IsArg(fn) {
			continue
		}

		cmd, err := p.parseCommand(fn)
		if err != nil {
			return nil, err
		}

		res = append(res, cmd)
	}
	return res, nil
}

func (p *uiparser) Funcs() []*doc.Func {
	funcs := []*doc.Func{}
	for _, t := range p.pkg.Types {
		for _, f := range t.Methods {
			if f.Recv == p.Recv {
				funcs = append(funcs, f)
			}
		}
	}
	return funcs
}

var tagLineRE = regexp.MustCompile(`^\s*(\w+): (.+)`)
var tagSepRE = regexp.MustCompile(`\b +|, *\b`)
var validTagRE = regexp.MustCompile(`[\w_:-]+`)

var notTagLine = fmt.Errorf("the given line is of the form `Kind: tag1, tag2, ...`")

func parseTagLine(line string) (kind string, tags []string, err error) {
	match := tagLineRE.FindStringSubmatch(line)
	if match == nil {
		return "", nil, notTagLine
	}

	kind = match[1]
	tags = tagSepRE.Split(match[2], -1)
	if len(tags) == 0 {
		err = fmt.Errorf(`no tags found on line: %q`, line)
		return
	}
	for i, t := range tags {
		if !validTagRE.MatchString(t) {
			tags = nil
			err = fmt.Errorf(`for %q: tag %d contains invalid characters: %q`, kind, i, t)
			return
		}
	}
	return
}

func (p *uiparser) parseCommand(fn *doc.Func) (Command, error) {
	// TODO: line numbers in error messages
	desc, err := p.ParseDescription(fn)
	if err != nil {
		return Command{}, err
	}
	desc.Name = transformName(desc.Name, p.CommandStyle)

	errprefix := fmt.Sprintf("%s: cannot parse script.Command: ", p.fmtfunc(fn))

	cmd := Command{Description: *desc}
	lines := strings.Split(desc.Long, "\n")
	retained := make([]string, 0, len(lines))
	for _, l := range lines {
		kind, tags, err := parseTagLine(l)
		if err != nil && err != notTagLine {
			return cmd, fmt.Errorf(errprefix+"%v", err)
		}
		switch kind {
		case "Required":
			for _, argname := range tags {
				if arg := p.UI.GetArg(argname); arg == nil {
					return cmd, fmt.Errorf(errprefix+`declared arg is not defined: %q`, argname)
				}
			}
			cmd.Required = tags
		case "Optional":
			for _, argname := range tags {
				if arg := p.UI.GetArg(argname); arg == nil {
					return cmd, fmt.Errorf(errprefix+`declared arg is not defined: %q`, argname)
				}
			}
			cmd.Required = tags
		default:
			retained = append(retained, l)
		}
	}

	cmd.Long = strings.Join(retained, "\n")
	return cmd, nil
}

func parseShortLong(name, text string) (*Description, error) {
	res := &Description{}
	synposis := doc.Synopsis(text)
	// TODO: improve this trimming
	trimmed := strings.TrimPrefix(strings.TrimPrefix(synposis, name+" "), "is ")
	if len(trimmed) > 0 {
		trimmed = strings.ToTitle(trimmed[0:1]) + trimmed[1:]
	}
	res.Short = trimmed
	if res.Short == "" {
		return nil, fmt.Errorf(`a synposis comment of the form "%s ..." is required`, name)
	}
	// TODO: remove the synposis sentence
	// This probably won't work
	res.Long = strings.TrimSpace(strings.TrimPrefix(text, synposis))
	return res, nil
}

// ParseDescription parses a description from a function declaration
func (p *uiparser) ParseDescription(fn *doc.Func) (*Description, error) {
	res, err := parseShortLong(fn.Name, fn.Doc)
	if err != nil {
		return nil, fmt.Errorf("%s: %v", p.fmtfunc(fn), err)
	}
	res.Name = fn.Name
	res.Original = fn.Name

	// parse tags
	out := make([]string, 0)
	for _, l := range strings.Split(res.Long, "\n") {
		kind, ts, err := parseTagLine(l)
		if err != nil && err != notTagLine {
			return nil, fmt.Errorf("%s: %v", p.fmtfunc(fn), err)
		}
		if kind == "Tags" {
			res.Tags = ts
		} else {
			out = append(out, l)
		}
	}

	res.Long = strings.Join(out, "\n")
	return res, nil
}

func (p *uiparser) fmtfunc(fn *doc.Func) string {
	proto := *fn.Decl
	proto.Body = nil
	proto.Doc = nil
	var out bytes.Buffer
	printer.Fprint(&out, p.fset, &proto)
	return fmt.Sprintf("%s `%s`", p.fset.Position(proto.Pos()), out.String())
}
