package script

import (
	"bytes"
	"fmt"
	"github.com/iancoleman/strcase"
	"github.com/kr/pretty"
	"go/doc"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"regexp"
	"strings"
	"text/template"
)

const importPath = "github.com/justjake/go-scripting/script"

const templateRaw = `package {{ .Package }}

// THIS FILE WAS AUTO-GENERATED BY go-scripting-ui.
// RUN 'go generate' TO UPDATE IT.

import "{{ .ImportPath }}"

// UI is an auto-generated script.UI that describes this program's commands and arguments.
var UI = {{ .UI }}
`

var tmpl = template.Must(template.New("file").Parse(templateRaw))

// NameStyle defines how UI will transform names from those in the file to
// those used in the UI.
type NameStyle string

const (
	// NoChange means names will not be transformed
	NoChange = ""
	// KebabCase means NamesOfAny_Format will end up like names-of-any-format
	KebabCase = "kebab-case"
	// ScreamingSnakeCase means NamesOfAny_Format will end up like NAMES_OF_ANY_FORMAT
	ScreamingSnakeCase = "SNAKE_CASE"
)

type uiparser struct {
	fset *token.FileSet
	pkg  *doc.Package
	*UI
	CommandStyle NameStyle
	ArgStyle     NameStyle
	IsArg        func(*doc.Func) bool
	IsCommand    func(*doc.Func) bool
}

// IsPublic returns true if the function is public.
func IsPublic(fn *doc.Func) bool {
	return string(fn.Name[0]) == strings.ToUpper(string(fn.Name[0]))
}

// IsScreamingSnake returns true if the function is named in SCREAMING_SNAKE_CASE
func IsScreamingSnake(fn *doc.Func) bool {
	return fn.Name == strcase.ToScreamingSnake(fn.Name)
}

func transformName(name string, style NameStyle) string {
	if style == KebabCase {
		return strcase.ToKebab(name)
	}

	if style == ScreamingSnakeCase {
		return strcase.ToScreamingSnake(name)
	}

	return name
}

func loadPackageAt(path string) (*token.FileSet, *doc.Package, error) {
	fset := token.NewFileSet()
	packages, err := parser.ParseDir(fset, path, nil, parser.ParseComments)
	if err != nil {
		return nil, nil, err
	}
	if len(packages) != 1 {
		return nil, nil, fmt.Errorf("wrong number of packages; should be one: %v", packages)
	}
	for _, pkg := range packages {
		return fset, doc.New(pkg, path, 0), nil
	}
	return nil, nil, fmt.Errorf("unreachable")
}

// Parse parses a package's documentation into a UI structure.
func Parse(fset *token.FileSet, pkg *doc.Package) (*UI, error) {
	p := &uiparser{
		fset:         fset,
		pkg:          pkg,
		UI:           &UI{},
		CommandStyle: KebabCase,
		ArgStyle:     "",
		IsCommand:    IsPublic,
		IsArg:        IsScreamingSnake,
	}
	var err error

	p.UI.Args, err = p.FindArgs()
	if err != nil {
		return nil, err
	}

	p.UI.Commands, err = p.FindCommands()
	if err != nil {
		return nil, err
	}

	return p.UI, nil
}

// Serialize a UI as Golang source code
func Serialize(ui *UI) string {
	var tmp bytes.Buffer
	pretty.Fprintf(&tmp, "%# v", ui)
	bytes := tmp.Bytes()

	// the pretty printer we use should output slice type names, but does not.
	// so we manually re-add slice type names.
	bytes = regexp.MustCompile(`(?m)^(\s+)Commands:\s+\{`).ReplaceAll(
		bytes, []byte("${1}Commands: []script.Command{"))
	bytes = regexp.MustCompile(`(?m)^(\s+)Args:\s+\{`).ReplaceAll(
		bytes, []byte("${1}Commands: []script.Arg{"))
	bytes = regexp.MustCompile(`(?m)^(\s+)(Optional|Required|Tags):\s+\{`).ReplaceAll(
		bytes, []byte("${1}${2}: []string{"))

	// format with the go source code formatter
	fmted, err := format.Source(bytes)
	if err != nil {
		panic(err)
	}

	return string(fmted)
}

func ToFileContents(ui *UI) string {
	var out bytes.Buffer
	params := struct {
		Package    string
		ImportPath string
		UI         string
	}{
		Package:    "main",
		ImportPath: importPath,
		UI:         Serialize(ui),
	}
	err := tmpl.Execute(&out, params)
	if err != nil {
		panic(err)
	}
	formatted, err := format.Source(out.Bytes())
	if err != nil {
		panic(err)
	}
	return string(formatted)
}

func (p *uiparser) FindArgs() ([]Arg, error) {
	res := []Arg{}

	for _, fn := range p.Funcs() {
		if !p.IsArg(fn) {
			continue
		}

		desc, err := p.ParseDescription(fn)
		if err != nil {
			return nil, fmt.Errorf("%s: cannot parse script.Arg: %v", p.fmtfunc(fn), err)
		}
		desc.Name = transformName(desc.Name, p.ArgStyle)

		res = append(res, Arg{*desc})
	}
	return res, nil
}

func (p *uiparser) FindCommands() ([]Command, error) {
	res := []Command{}
	for _, fn := range p.Funcs() {
		if !p.IsCommand(fn) {
			continue
		}
		if p.IsArg(fn) {
			continue
		}

		cmd, err := p.parseCommand(fn)
		if err != nil {
			return nil, err
		}

		res = append(res, cmd)
	}
	return res, nil
}

func (p *uiparser) Funcs() []*doc.Func {
	funcs := append([]*doc.Func{}, p.pkg.Funcs...)
	for _, t := range p.pkg.Types {
		funcs = append(funcs, t.Funcs...)
		funcs = append(funcs, t.Methods...)
	}
	return funcs
}

var optionalArgs = regexp.MustCompile(`^\s*Optional: (.+)`)
var requiredArgs = regexp.MustCompile(`^\s*Required: (.+)`)
var tags = regexp.MustCompile(`^\s*Tags: (.*)`)
var sep = regexp.MustCompile(`\b +|, *\b`)
var name = regexp.MustCompile(`[\w_]+`)

func parseNames(text string) ([]string, error) {
	names := sep.Split(text, -1)
	if len(names) == 0 {
		return nil, fmt.Errorf(`no names found: %q`, text)
	}
	for i, n := range names {
		if !name.MatchString(n) {
			return nil, fmt.Errorf(`name %d contains invalid characters: %q`, i, n)
		}
	}
	return names, nil
}

func parseTags(line string, capture *regexp.Regexp) ([]string, error) {
	if m := capture.FindStringSubmatch(line); m != nil {
		res, err := parseNames(m[1])
		if err != nil {
			return nil, err
		}
		return res, nil
	}
	return nil, nil
}

func (p *uiparser) parseCommand(fn *doc.Func) (Command, error) {
	// TODO: line numbers in error messages
	desc, err := p.ParseDescription(fn)
	if err != nil {
		return Command{}, err
	}
	desc.Name = transformName(desc.Name, p.CommandStyle)

	errprefix := fmt.Sprintf("%s: cannot parse script.Command: ", p.fmtfunc(fn))

	cmd := Command{Description: *desc}
	lines := strings.Split(desc.Long, "\n")
	retained := make([]string, 0, len(lines))
	for _, l := range lines {
		optional, err := parseTags(l, optionalArgs)
		if err != nil {
			return cmd, fmt.Errorf(errprefix+`can't parse "Optional:": %v`, err)
		}
		if optional != nil {
			for _, argname := range optional {
				if arg := p.UI.GetArg(argname); arg == nil {
					return cmd, fmt.Errorf(errprefix+`declared arg is not defined: %q`, argname)
				}
			}
			cmd.Optional = optional
			continue
		}

		required, err := parseTags(l, requiredArgs)
		if err != nil {
			return cmd, fmt.Errorf(errprefix+`can't parse "Required:": %v`, err)
		}
		if required != nil {
			for _, argname := range required {
				if arg := p.UI.GetArg(argname); arg == nil {
					return cmd, fmt.Errorf(errprefix+`arg %q not defined: %q`, argname, l)
				}
			}
			cmd.Required = required
			continue
		}
		retained = append(retained, l)
	}

	cmd.Long = strings.Join(retained, "\n")
	return cmd, nil
}

func parseShortLong(name, text string) (*Description, error) {
	res := &Description{}
	synposis := doc.Synopsis(text)
	// TODO: improve this trimming
	trimmed := strings.TrimPrefix(strings.TrimPrefix(synposis, name+" "), "is ")
	if len(trimmed) > 0 {
		trimmed = strings.ToTitle(trimmed[0:1]) + trimmed[1:]
	}
	res.Short = trimmed
	if res.Short == "" {
		return nil, fmt.Errorf(`a synposis comment of the form "%s ..." is required`, name)
	}
	// TODO: remove the synposis sentence
	// This probably won't work
	res.Long = strings.TrimSpace(strings.TrimPrefix(text, synposis))
	return res, nil
}

// ParseDescription parses a description from a function declaration
func (p *uiparser) ParseDescription(fn *doc.Func) (*Description, error) {
	res, err := parseShortLong(fn.Name, fn.Doc)
	if err != nil {
		return nil, fmt.Errorf("for func %v (%v): %v", fn.Name, p.fset.Position(fn.Decl.Pos()), err)
	}
	res.Name = fn.Name
	res.Original = fn.Name

	// parse tags
	for _, l := range strings.Split(fn.Doc, "\n") {
		ts, err := parseTags(l, tags)
		if err != nil {
			return nil, fmt.Errorf(`can't parse "Tags:": %v`, err)
		}
		if len(ts) != 0 {
			res.Tags = ts
		}
	}

	return res, nil
}

func (p *uiparser) fmtfunc(fn *doc.Func) string {
	proto := *fn.Decl
	proto.Body = nil
	proto.Doc = nil
	var out bytes.Buffer
	printer.Fprint(&out, p.fset, &proto)
	return fmt.Sprintf("%s `%s`", p.fset.Position(proto.Pos()), out.String())
}
